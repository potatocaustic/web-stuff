<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>RKL Season 7 Leaderboards - caustic.info</title>
    <link rel="icon" href="https://raw.githubusercontent.com/potatocaustic/web-stuff/refs/heads/main/favicon.ico" type="image/x-icon" />
    <style>
      /* Reset and General Styles */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: Arial, sans-serif;
        background-color: #f4f4f4;
        color: #333;
        line-height: 1.6;
      }
      h1, h2, h3 { color: #333; }
      header {
        background-color: #333;
        color: #fff;
        padding: 1rem;
        text-align: center;
      }
      header h1 { color: white !important; font-size: 1.5rem; margin: 0; }
      nav ul { display: flex; justify-content: center; list-style: none; margin-top: 1rem; flex-wrap: wrap; }
      nav ul li { margin: 0.5rem 1rem; }
      nav ul li a { color: #fff; text-decoration: none; font-size: 1.1rem; transition: color 0.3s ease; }
      nav ul li a:hover { color: #ccc; }
      main { padding: 2rem; max-width: 1200px; margin: 0 auto; }
      .page-header { text-align: center; margin-bottom: 2rem; }
      .page-header h2 { font-size: 2.5rem; margin-bottom: 1rem; }
      .filter-controls {
        background-color: #fff;
        border-radius: 8px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        padding: 1.5rem;
        margin-bottom: 2rem;
        display: flex;
        gap: 1rem;
        align-items: center;
        justify-content: center;
        flex-wrap: wrap;
      }
      .filter-group { display: flex; flex-direction: column; gap: 0.5rem; }
      .filter-group label { font-weight: 500; font-size: 0.9rem; }
      .filter-group select {
        padding: 0.5rem;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 1rem;
        min-width: 200px;
      }
      .leaderboard-container {
        background-color: #fff;
        border-radius: 8px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        overflow-x: auto; /* For table responsiveness */
      }
      .leaderboard-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 1.5rem;
        font-size: 0.95em;
      }
      .leaderboard-table th, .leaderboard-table td {
        text-align: left;
        padding: 10px 12px; 
        border-bottom: 1px solid #eee;
        vertical-align: top; 
      }
      .leaderboard-table th {
        background-color: #333;
        color: white;
        cursor: pointer;
        position: sticky; 
        top: 0;          
        z-index: 1;
      }
      .leaderboard-table th:hover { background-color: #444; }
      .leaderboard-table tbody tr:hover { background-color: #f8f9fa; }
      .leaderboard-table td:first-child, .leaderboard-table th:first-child { text-align: center; } /* Rank */
      
      /* MODIFIED CSS for ellipses */
      .player-name, .team-name-leaderboard {
        display: flex;
        align-items: center;
        gap: 8px;
        max-width: 220px; /* Increased from 120px */
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .player-name a { color: #007bff; text-decoration: none; font-weight: bold;}
      .player-name a:hover { text-decoration: underline; }
      .player-team-name {
        font-size: 0.85em;
        color: #555;
        max-width: 180px; /* Increased from 100px */
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        display: block; 
        margin-top: 2px; 
      }
      /* END MODIFIED CSS */

      .team-logo-inline {
        width: 20px;
        height: 20px;
        vertical-align: middle;
        margin-right: 0px; 
        border-radius: 3px;
      }
      .sort-indicator { margin-left: 5px; }
      .loading, .error, .no-players { text-align: center; padding: 3rem; color: #666; font-size: 1.1rem; }
      .error { color: #dc3545; background-color: #f8d7da; border-radius: 4px; margin: 1rem; }
      .no-players { font-style: italic; }
      footer { text-align: center; margin-top: 3rem; padding: 1rem; background-color: #333; color: #fff; }

      @media (max-width: 768px) {
        .filter-controls { flex-direction: column; align-items: stretch; }
        .filter-group select { min-width: auto; width: 100%; }
        .leaderboard-table { font-size: 0.85em; }
        .leaderboard-table th, .leaderboard-table td { padding: 8px 6px; }
        /* Further adjustments for ellipses on smaller screens if needed */
        .player-name, .team-name-leaderboard { max-width: 150px; } 
        .player-team-name { max-width: 120px; }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>RKL Season 7 Leaderboards</h1>
      <nav>
        <ul>
          <li><a href="../../index.html">Home</a></li>
          <li><a href="../rkl-stats.html">RKL Stats Database</a></li>
          <li><a href="RKL-S7.html">Season 7</a></li>
          <li><a href="standings.html">Standings</a></li>
          <li><a href="leaderboards.html">Leaderboards</a></li>
          <li><a href="transactions.html">Transactions</a></li>
        </ul>
      </nav>
    </header>
    
    <main>
      <div class="page-header">
        <h2>Player Leaderboards</h2>
        <p>Rankings based on various performance metrics.</p>
      </div>

      <div class="filter-controls">
        <div class="filter-group">
          <label for="metric-select">Leaderboard Metric:</label>
          <select id="metric-select">
            <option value="rel_median">Median REL</option>
            <option value="avg_score">Average Score</option>
            <option value="median_rank_raw">Median Global Rank</option>
            <option value="wins">Wins</option>
            <option value="karma_score_รวม">Total Karma</option>
            <option value="win_percentage">Win Percentage</option>
            <option value="rel_median_plus_wins">REL + Wins Score</option>
            <option value="consistency_score">Consistency Score</option>
            <option value="games_played">Games Played</option>
          </select>
        </div>
        <div class="filter-group">
          <label for="team-select">Filter by Team:</label>
          <select id="team-select">
            <option value="all">All Teams</option>
            </select>
        </div>
      </div>

      <div class="leaderboard-container">
        <table class="leaderboard-table">
          <thead id="leaderboard-table-head">
            <tr>
              <th data-sort-key="rank">Rank</th>
              <th data-sort-key="player_name">Player</th>
              <th data-sort-key="team_name">Team</th>
              <th data-sort-key="games_played">GP</th>
              <th data-sort-key="metric_value">Metric Value</th> 
            </tr>
          </thead>
          <tbody id="leaderboard-table-body">
            <tr><td colspan="5" class="loading">Loading leaderboard...</td></tr>
          </tbody>
        </table>
      </div>
    </main>
    
    <footer>
      <p>&copy; caustic.info</p>
    </footer>

    <script>
      const SHEET_ID = '12EembQnztbdKx2-buv00--VDkEFSTuSXTRdOnTnRxq4';
      const BASE_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:csv&sheet=`;
      
      let allPlayers = [];
      let allTeams = [];
      let allLineupsData = [];
      let allWeeklyAverages = [];
      let currentPlayersForTable = []; // Holds players filtered for display, will be sorted by table headers

      const metrics = {
        'rel_median': { label: 'Median REL', getValue: p => p.relMedian || 0, sortOrder: 'desc', format: val => typeof val === 'number' ? val.toFixed(3) : '-' },
        'avg_score': { label: 'Average Score', getValue: p => p.avg_score || 0, sortOrder: 'desc', format: val => typeof val === 'number' ? val.toFixed(1) : '-' },
        'median_rank_raw': { label: 'Median Global Rank', getValue: p => p.median_rank_raw === '-' ? Infinity : (p.median_rank_raw || Infinity), sortOrder: 'asc', format: val => (val === Infinity || val === '-') ? '-' : Math.round(val) },
        'wins': { label: 'Wins', getValue: p => p.wins || 0, sortOrder: 'desc', format: val => val },
        'karma_score_รวม': { label: 'Total Karma', getValue: p => p.total_karma || 0, sortOrder: 'desc', format: val => Math.round(val) },
        'win_percentage': { label: 'Win Percentage', getValue: p => p.win_percentage || 0, sortOrder: 'desc', format: val => `${(val * 100).toFixed(1)}%` },
        'rel_median_plus_wins': { label: 'REL + Wins Score', getValue: p => p.rel_median_plus_wins || 0, sortOrder: 'desc', format: val => val.toFixed(3) },
        'consistency_score': { label: 'Consistency Score', getValue: p => p.consistency_score || 0, sortOrder: 'desc', format: val => val.toFixed(3) },
        'games_played': { label: 'Games Played', getValue: p => p.games_played || 0, sortOrder: 'desc', format: val => val }
      };

      async function fetchSheetData(sheetName) {
        try {
          const response = await fetch(BASE_URL + encodeURIComponent(sheetName));
          if (!response.ok) throw new Error(`HTTP error! status: ${response.status} for ${sheetName}`);
          const csvText = await response.text();
          return parseCSV(csvText);
        } catch (error) {
          console.error(`Error fetching ${sheetName}:`, error);
          const tableBody = document.getElementById('leaderboard-table-body');
          if (tableBody) tableBody.innerHTML = `<tr><td colspan="5" class="error">Error loading data sheet: ${sheetName}</td></tr>`;
          return null;
        }
      }
      
      function parseCSV(csvText) {
        const lines = csvText.trim().split('\n');
        const headers = lines[0].split(',').map(h => h.replace(/^"|"$/g, '').trim());
        const data = [];
        for (let i = 1; i < lines.length; i++) {
            const values = [];
            let currentVal = '';
            let inQuotes = false;
            for (let j = 0; j < lines[i].length; j++) {
                const char = lines[i][j];
                if (char === '"' && (j === 0 || lines[i][j-1] !== '\\')) { 
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    values.push(currentVal.replace(/^"|"$/g, '').trim());
                    currentVal = '';
                } else {
                    currentVal += char;
                }
            }
            values.push(currentVal.replace(/^"|"$/g, '').trim());
            if (values.length === headers.length) {
                const row = {};
                headers.forEach((header, index) => {
                    row[header] = values[index] || '';
                });
                data.push(row);
            }
        }
        return data;
      }

      function getTeamData(teamId) {
        if (!teamId) return { team_id: teamId, team_name: 'N/A', abbreviation: 'N/A' };
        const team = allTeams.find(t => t.team_id === teamId);
        return team || { team_id: teamId, team_name: teamId, abbreviation: teamId };
      }

      function getTeamLogo(teamId) {
        if (!teamId) return '';
        const team = getTeamData(teamId);
        return `<img src="icons/${encodeURIComponent(String(team.team_id || ''))}.webp" alt="${team.team_name}" class="team-logo-inline" onerror="this.style.display='none'">`;
      }

      function parsePlayerNumber(value) {
        if (value === null || value === undefined || value === '') return 0;
        const cleaned = String(value).replace(/,/g, '');
        const parsed = parseFloat(cleaned);
        return isNaN(parsed) ? 0 : parsed;
      }
      
      function calculatePlayerRELMedian(playerHandle, weeklyAvgs, lineups) {
        const playerGames = lineups.filter(lineup => lineup.player_handle === playerHandle && (String(lineup.started).toLowerCase() === 'true' || lineup.started === true || lineup.started === 1));
        if (playerGames.length === 0) return 0;
        const weeklyAveragesMap = {};
        (weeklyAvgs || []).forEach(week => { if (week.date) weeklyAveragesMap[week.date] = { median_score: parsePlayerNumber(week.median_score) }; });
        let totalPlayerKarma = 0, totalMedianKarma = 0, validGames = 0;
        playerGames.forEach(game => {
          if (weeklyAveragesMap[game.date]) {
            totalPlayerKarma += parsePlayerNumber(game.points_raw);
            totalMedianKarma += weeklyAveragesMap[game.date].median_score;
            validGames++;
          }
        });
        const avgPlayerKarma = validGames > 0 ? totalPlayerKarma / validGames : 0;
        const avgMedianKarma = validGames > 0 ? totalMedianKarma / validGames : 0;
        return avgMedianKarma > 0 ? (avgPlayerKarma / avgMedianKarma) : 0;
      }

      function calculatePlayerMedianRank(playerHandle, lineups) {
        const playerGames = lineups.filter(lineup => lineup.player_handle === playerHandle && (String(lineup.started).toLowerCase() === 'true' || lineup.started === true || lineup.started === 1) && lineup.global_rank && parsePlayerNumber(lineup.global_rank) > 0);
        if (playerGames.length === 0) return 0;
        const ranks = playerGames.map(game => parsePlayerNumber(game.global_rank)).sort((a, b) => a - b);
        const mid = Math.floor(ranks.length / 2);
        return ranks.length % 2 === 0 ? (ranks[mid - 1] + ranks[mid]) / 2 : ranks[mid];
      }

      async function precalculateAllPlayerStats() {
        const enrichedPlayers = [];
        for (const rawPlayer of allPlayers) { // allPlayers is initially raw data
            const playerHandle = rawPlayer.player_handle;
            const gamesPlayedList = allLineupsData.filter(l => l.player_handle === playerHandle && (String(l.started).toLowerCase() === 'true' || l.started === true || l.started === 1));
            const gamesPlayed = gamesPlayedList.length;
            
            let totalScore = 0;
            let wins = 0, losses = 0, ties = 0;
            let scores = [];

            gamesPlayedList.forEach(l => {
                const score = parsePlayerNumber(l.points_raw);
                totalScore += score;
                scores.push(score);
                if (String(l.win).toLowerCase() === 'true' || l.win === 1) wins++;
                else if (String(l.loss).toLowerCase() === 'true' || l.loss === 1) losses++;
                else if (String(l.tie).toLowerCase() === 'true' || l.tie === 1) ties++;
            });
            
            const avgScore = gamesPlayed > 0 ? totalScore / gamesPlayed : 0;
            const relMedian = calculatePlayerRELMedian(playerHandle, allWeeklyAverages, allLineupsData);
            const medianRank = calculatePlayerMedianRank(playerHandle, allLineupsData);
            const teamInfo = getTeamData(rawPlayer.team_id);
            
            const stdDev = gamesPlayed > 1 ? Math.sqrt(scores.reduce((acc, val) => acc + Math.pow(val - avgScore, 2), 0) / (gamesPlayed -1)) : 0;
            const consistency_score = avgScore > 0 ? (stdDev / avgScore) : Infinity; // Lower is better (less variable relative to mean) - treat 0 avg score carefully


            enrichedPlayers.push({
                ...rawPlayer, // Keep original fields like player_handle, team_id
                games_played: gamesPlayed,
                avg_score: avgScore,
                wins: wins,
                losses: losses,
                ties: ties,
                total_karma: totalScore,
                win_percentage: gamesPlayed > 0 ? wins / gamesPlayed : 0,
                relMedian: relMedian,
                median_rank_raw: medianRank > 0 ? medianRank : '-',
                rel_median_plus_wins: relMedian + (wins * 0.1), // Example composite score
                consistency_score: consistency_score === Infinity ? Infinity : (1 - consistency_score), // Higher is better after inversion (1 - CV)
                team_name: teamInfo.team_name,
                team_abbreviation: teamInfo.abbreviation
            });
        }
        allPlayers = enrichedPlayers; // Replace raw with enriched
      }

      async function loadData() {
        const rawPlayers = await fetchSheetData('Players');
        if (!rawPlayers) return;
        allPlayers = rawPlayers; // Start with raw players

        const [teamsData, lineupsData, weeklyAvgsData] = await Promise.all([
          fetchSheetData('Teams'),
          fetchSheetData('Lineups'),
          fetchSheetData('Weekly_Averages')
        ]);

        if (!teamsData || !lineupsData || !weeklyAvgsData) {
            const tableBody = document.getElementById('leaderboard-table-body');
            if (tableBody) tableBody.innerHTML = `<tr><td colspan="5" class="error">Error loading auxiliary data.</td></tr>`;
            return;
        }
        allTeams = teamsData;
        allLineupsData = lineupsData;
        allWeeklyAverages = weeklyAvgsData;
        
        await precalculateAllPlayerStats(); // Enrich allPlayers

        setupFilters();
        // Set default sort to match initial metric before first display
        const initialMetricKey = document.getElementById('metric-select').value;
        sortConfig.key = 'metric_value'; // We are always sorting the 'Metric Value' column
        sortConfig.direction = metrics[initialMetricKey] ? metrics[initialMetricKey].sortOrder : 'desc';
        displayLeaderboard();
      }

      function setupFilters() {
        const teamSelect = document.getElementById('team-select');
        const metricSelect = document.getElementById('metric-select');

        const teamOptions = allTeams
          .filter(team => team.team_id && team.team_name && team.team_id !== "FA")
          .sort((a, b) => a.team_name.localeCompare(b.team_name))
          .map(team => `<option value="${team.team_id}">${team.team_name}</option>`)
          .join('');
        teamSelect.innerHTML = '<option value="all">All Teams</option>' + teamOptions;

        metricSelect.value = 'rel_median'; // Default metric

        teamSelect.addEventListener('change', displayLeaderboard);
        metricSelect.addEventListener('change', () => {
            // When metric changes, reset table sort to be by the new metric's value column
            const newMetricKey = metricSelect.value;
            sortConfig.key = 'metric_value'; // Sort by the actual metric value column
            sortConfig.direction = metrics[newMetricKey] ? metrics[newMetricKey].sortOrder : 'desc';
            displayLeaderboard();
        });
      }
      
      let sortConfig = { key: 'metric_value', direction: 'desc' }; // Default: sort by metric value, descending

      function displayLeaderboard() {
        const metricSelect = document.getElementById('metric-select');
        const teamSelect = document.getElementById('team-select');
        const selectedMetricKey = metricSelect.value;
        const selectedTeam = teamSelect.value;

        const metricDefinition = metrics[selectedMetricKey];
        if (!metricDefinition) {
            console.error("Invalid metric selected:", selectedMetricKey);
            return;
        }
        
        document.querySelector('#leaderboard-table-head th[data-sort-key="metric_value"]').textContent = metricDefinition.label;

        // 1. Create a list of all players eligible for this leaderboard (GP > 0)
        let rankablePlayers = allPlayers.filter(p => p.games_played > 0);

        // 2. Sort these players by the selected metric to assign ranks
        rankablePlayers.sort((a, b) => {
            const valA = metricDefinition.getValue(a);
            const valB = metricDefinition.getValue(b);
            if (valA === valB) return 0;
            // Handle Infinity for sorting
            if (metricDefinition.sortOrder === 'asc') { // Lower is better
                if (valA === Infinity) return 1;  
                if (valB === Infinity) return -1; 
                return valA - valB;
            } else { // desc, Higher is better
                if (valA === Infinity) return -1; // Should be treated as "worst"
                if (valB === Infinity) return 1;
                return valB - valA;
            }
        });

        // 3. Assign sticky ranks (standard competition ranking: 1, 2, 2, 4)
        if (rankablePlayers.length > 0) {
            rankablePlayers[0].leaderboardDisplayRank = 1;
            for (let i = 1; i < rankablePlayers.length; i++) {
                const currentPlayer = rankablePlayers[i];
                const prevPlayer = rankablePlayers[i-1];
                const currentValue = metricDefinition.getValue(currentPlayer);
                const prevValue = metricDefinition.getValue(prevPlayer);
                if (currentValue === prevValue) {
                    currentPlayer.leaderboardDisplayRank = prevPlayer.leaderboardDisplayRank;
                } else {
                    currentPlayer.leaderboardDisplayRank = i + 1; 
                }
            }
        }
        
        // 4. Filter by selected team for display
        currentPlayersForTable = rankablePlayers.filter(p => selectedTeam === 'all' || p.team_id === selectedTeam);
        
        // 5. Apply the current table sort config (which might be different from the primary metric sort)
        // This is important if the user had clicked a different column header.
        // However, if the metric just changed, we want the table sorted by that metric's value.
        // The event listener for metricSelect already sets sortConfig.key to 'metric_value' and its direction.
        applyTableSort(); // This function will sort currentPlayersForTable based on sortConfig

        updateTableHeaders();
        populateTable();
      }
      
      function applyTableSort() {
        if (!currentPlayersForTable) return;

        currentPlayersForTable.sort((a, b) => {
            let valA, valB;
            const key = sortConfig.key;

            if (key === 'rank') {
                valA = a.leaderboardDisplayRank;
                valB = b.leaderboardDisplayRank;
            } else if (key === 'player_name') {
                valA = a.player_handle.toLowerCase();
                valB = b.player_handle.toLowerCase();
            } else if (key === 'team_name') {
                valA = (a.team_name || "").toLowerCase();
                valB = (b.team_name || "").toLowerCase();
            } else if (key === 'games_played') {
                valA = metrics['games_played'].getValue(a);
                valB = metrics['games_played'].getValue(b);
            } else if (key === 'metric_value') {
                const metricDefinition = metrics[document.getElementById('metric-select').value];
                valA = metricDefinition.getValue(a);
                valB = metricDefinition.getValue(b);
            } else { // Should not happen with defined headers
                return 0;
            }
            
            const isAsc = sortConfig.direction === 'asc';
            if (valA === Infinity && valB === Infinity) return 0;
            if (valA === Infinity) return isAsc ? 1 : -1;
            if (valB === Infinity) return isAsc ? -1 : 1;
            if (valA === null || valA === undefined || (typeof valA === 'number' && isNaN(valA))) valA = isAsc ? Infinity : -Infinity;
            if (valB === null || valB === undefined || (typeof valB === 'number' && isNaN(valB))) valB = isAsc ? Infinity : -Infinity;

            if (typeof valA === 'string' && typeof valB === 'string') {
                return isAsc ? valA.localeCompare(valB) : valB.localeCompare(valA);
            } else {
                return isAsc ? valA - valB : valB - valA;
            }
        });
      }


      function sortTableByColumn(columnKey) {
        const currentMetricKey = document.getElementById('metric-select').value;
        const currentMetricDefinition = metrics[currentMetricKey];

        if (sortConfig.key === columnKey) {
            sortConfig.direction = sortConfig.direction === 'asc' ? 'desc' : 'asc';
        } else {
            sortConfig.key = columnKey;
            if (columnKey === 'metric_value') {
                sortConfig.direction = currentMetricDefinition.sortOrder;
            } else if (columnKey === 'player_name' || columnKey === 'team_name') {
                sortConfig.direction = 'asc';
            } else if (columnKey === 'rank' || columnKey === 'games_played') {
                 sortConfig.direction = 'asc'; // GP typically asc for secondary sort, rank always asc
            } else {
                sortConfig.direction = 'desc'; // Default for other numeric types
            }
        }
        applyTableSort();
        updateTableHeaders();
        populateTable();
      }
      
      function populateTable() {
        const tableBody = document.getElementById('leaderboard-table-body');
        tableBody.innerHTML = ''; 

        if (currentPlayersForTable.length === 0) {
            const row = tableBody.insertRow();
            const cell = row.insertCell();
            const headerCells = document.getElementById('leaderboard-table-head').rows[0].cells.length;
            cell.colSpan = headerCells > 0 ? headerCells : 5;
            cell.textContent = 'No players match the current filters.';
            cell.className = 'no-players';
            return;
        }
        
        const selectedMetricKey = document.getElementById('metric-select').value;
        const metricDefinition = metrics[selectedMetricKey];

        currentPlayersForTable.forEach((player) => {
            const row = tableBody.insertRow();
            
            row.insertCell().textContent = player.leaderboardDisplayRank; // Sticky rank

            const nameCell = row.insertCell();
            const playerIconHTML = getTeamLogo(player.team_id);
            // Spans for name and team are used for ellipsis styling
            nameCell.innerHTML = `<span class="player-name">${playerIconHTML} <a href="player.html?player=${encodeURIComponent(player.player_handle)}">${player.player_handle}</a></span>`;
            
            const teamCell = row.insertCell();
            teamCell.innerHTML = `<span class="team-name-leaderboard">${getTeamLogo(player.team_id)} ${player.team_name || 'N/A'}</span>`;
            
            row.insertCell().textContent = metrics['games_played'].format(player.games_played);
            row.insertCell().textContent = metricDefinition.format(metricDefinition.getValue(player));
        });
      }

      function updateTableHeaders() {
        const headers = document.querySelectorAll('#leaderboard-table-head th');
        const metricLabel = metrics[document.getElementById('metric-select').value].label;
        
        headers.forEach(th => {
            const key = th.dataset.sortKey;
            let baseText = th.textContent.replace(/ [▲▼]$/, '').trim(); // Clean old indicator and text

            if (key === 'metric_value') { // Update metric value header text
                baseText = metricLabel;
            } else if (key === 'rank') baseText = "Rank";
            else if (key === 'player_name') baseText = "Player";
            else if (key === 'team_name') baseText = "Team";
            else if (key === 'games_played') baseText = "GP";
            
            let indicator = '';
            if (key === sortConfig.key) {
                indicator = sortConfig.direction === 'asc' ? ' ▲' : ' ▼';
            }
            th.innerHTML = `${baseText}<span class="sort-indicator">${indicator}</span>`;
        });
      }

      document.addEventListener('DOMContentLoaded', loadData);
      document.getElementById('leaderboard-table-head').addEventListener('click', (event) => {
          const target = event.target.closest('th');
          if (target && target.dataset.sortKey) {
              sortTableByColumn(target.dataset.sortKey);
          }
      });
    </script>
  </body>
</html>
