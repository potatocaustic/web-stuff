<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>RKL Season 7 Leaderboards - caustic.info</title>
    <link rel="icon" href="https://raw.githubusercontent.com/potatocaustic/web-stuff/refs/heads/main/favicon.ico" type="image/x-icon" />
    <style>
      /* Reset and General Styles */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: Arial, sans-serif;
        background-color: #f4f4f4;
        color: #333;
        line-height: 1.6;
      }
      h1, h2, h3 { color: #333; }
      header {
        background-color: #333;
        color: #fff;
        padding: 1rem;
        text-align: center;
      }
      header h1 { color: white !important; font-size: 1.5rem; margin: 0; }
      nav ul { display: flex; justify-content: center; list-style: none; margin-top: 1rem; flex-wrap: wrap; }
      nav ul li { margin: 0.5rem 1rem; }
      nav ul li a { color: #fff; text-decoration: none; font-size: 1.1rem; transition: color 0.3s ease; }
      nav ul li a:hover { color: #ccc; }
      main { padding: 2rem; max-width: 1200px; margin: 0 auto; }
      .page-header { text-align: center; margin-bottom: 2rem; }
      .page-header h2 { font-size: 2.5rem; margin-bottom: 1rem; }
      .filter-controls {
        background-color: #fff;
        border-radius: 8px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        padding: 1.5rem;
        margin-bottom: 2rem;
        display: flex;
        gap: 1rem;
        align-items: center;
        justify-content: center;
        flex-wrap: wrap;
      }
      .filter-group { display: flex; flex-direction: column; gap: 0.5rem; }
      .filter-group label { font-weight: 500; font-size: 0.9rem; }
      .filter-group select {
        padding: 0.5rem;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 1rem;
        min-width: 200px;
      }
      .leaderboard-container {
        background-color: #fff;
        border-radius: 8px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        overflow-x: auto; /* For table responsiveness */
      }
      .leaderboard-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 1.5rem;
        font-size: 0.95em;
        /* table-layout: fixed; */ /* Keeping auto for now */
      }
      .leaderboard-table th, .leaderboard-table td {
        text-align: left;
        padding: 10px 12px; /* Increased padding slightly */
        border-bottom: 1px solid #eee;
        vertical-align: top; /* Align top for cells with multi-line content */
      }
      .leaderboard-table th {
        background-color: #333;
        color: white;
        cursor: pointer;
        position: sticky; /* If header needs to be sticky during vertical scroll */
        top: 0;           /* Required for sticky header */
        z-index: 1;
      }
      .leaderboard-table th:hover { background-color: #444; }
      .leaderboard-table tbody tr:hover { background-color: #f8f9fa; }
      .leaderboard-table td:first-child, .leaderboard-table th:first-child { text-align: center; } /* Rank */
      .player-name, .team-name-leaderboard {
        display: flex;
        align-items: center;
        gap: 8px;
        max-width: 220px; /* Increased from 120px */
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .player-name a { color: #007bff; text-decoration: none; font-weight: bold;}
      .player-name a:hover { text-decoration: underline; }
      .player-team-name {
        font-size: 0.85em;
        color: #555;
        max-width: 180px; /* Increased from 100px */
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        display: block; /* Ensures it takes its own line for ellipsis if player name is short */
        margin-top: 2px; /* Small space between player name and team name */
      }
      .team-logo-inline {
        width: 20px;
        height: 20px;
        vertical-align: middle;
        margin-right: 0px; /* Gap is handled by parent flex */
        border-radius: 3px;
      }
      .sort-indicator { margin-left: 5px; }
      .loading, .error, .no-players { text-align: center; padding: 3rem; color: #666; font-size: 1.1rem; }
      .error { color: #dc3545; background-color: #f8d7da; border-radius: 4px; margin: 1rem; }
      .no-players { font-style: italic; }
      footer { text-align: center; margin-top: 3rem; padding: 1rem; background-color: #333; color: #fff; }

      /* Responsive adjustments */
      @media (max-width: 768px) {
        .filter-controls { flex-direction: column; align-items: stretch; }
        .filter-group select { min-width: auto; width: 100%; }
        .leaderboard-table { font-size: 0.85em; }
        .leaderboard-table th, .leaderboard-table td { padding: 8px 6px; }
        .player-name, .team-name-leaderboard { max-width: 150px; } /* Adjust for smaller screens if needed */
        .player-team-name { max-width: 120px; }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>RKL Season 7 Leaderboards</h1>
      <nav>
        <ul>
          <li><a href="../../index.html">Home</a></li>
          <li><a href="../rkl-stats.html">RKL Stats Database</a></li>
          <li><a href="RKL-S7.html">Season 7</a></li>
          <li><a href="standings.html">Standings</a></li>
          <li><a href="leaderboards.html">Leaderboards</a></li>
          <li><a href="transactions.html">Transactions</a></li>
        </ul>
      </nav>
    </header>
    
    <main>
      <div class="page-header">
        <h2>Player Leaderboards</h2>
        <p>Rankings based on various performance metrics.</p>
      </div>

      <div class="filter-controls">
        <div class="filter-group">
          <label for="metric-select">Leaderboard Metric:</label>
          <select id="metric-select">
            <option value="rel_median">Median REL</option>
            <option value="avg_score">Average Score</option>
            <option value="median_rank_raw">Median Global Rank</option>
            <option value="wins">Wins</option>
            <option value="games_played">Games Played</option>
          </select>
        </div>
        <div class="filter-group">
          <label for="team-select">Filter by Team:</label>
          <select id="team-select">
            <option value="all">All Teams</option>
          </select>
        </div>
      </div>

      <div class="leaderboard-container">
        <table class="leaderboard-table">
          <thead id="leaderboard-table-head">
            <tr>
              <th data-sort-key="rank">Rank</th>
              <th data-sort-key="player_name">Player (Team)</th>
              <th data-sort-key="games_played">GP</th>
              <th data-sort-key="rel_median">Median REL</th>
              <th data-sort-key="avg_score">Avg Score</th>
              <th data-sort-key="median_rank_raw">Med Rank</th>
              <th data-sort-key="wins">Wins</th>
              <th data-sort-key="losses">Losses</th>
              <th data-sort-key="ties">Ties</th>
            </tr>
          </thead>
          <tbody id="leaderboard-table-body">
            <tr><td colspan="9" class="loading">Loading leaderboard...</td></tr>
          </tbody>
        </table>
      </div>
    </main>
    
    <footer>
      <p>&copy; caustic.info</p>
    </footer>

    <script>
      const SHEET_ID = '12EembQnztbdKx2-buv00--VDkEFSTuSXTRdOnTnRxq4';
      const BASE_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:csv&sheet=`;
      
      let allPlayers = []; // Will store enriched player data
      let allTeams = [];
      let allLineupsData = [];
      let allWeeklyAverages = [];
      let currentPlayersForDisplay = []; // Players currently shown in the table, sorted by table interaction

      const metrics = {
        'rel_median': { label: 'Median REL', getValue: p => p.relMedian || 0, sortOrder: 'desc', format: val => typeof val === 'number' ? val.toFixed(3) : '-' },
        'avg_score': { label: 'Avg Score', getValue: p => p.avg_score || 0, sortOrder: 'desc', format: val => typeof val === 'number' ? val.toFixed(1) : '-' },
        'median_rank_raw': { label: 'Median Global Rank', getValue: p => p.median_rank_raw === '-' ? Infinity : (p.median_rank_raw || Infinity), sortOrder: 'asc', format: val => (val === Infinity || val === '-') ? '-' : Math.round(val) },
        'wins': { label: 'Wins', getValue: p => p.wins || 0, sortOrder: 'desc', format: val => val },
        'losses': { label: 'Losses', getValue: p => p.losses || 0, sortOrder: 'desc', format: val => val }, // Note: sortOrder might be 'asc' if fewer is better
        'ties': { label: 'Ties', getValue: p => p.ties || 0, sortOrder: 'desc', format: val => val },
        'games_played': { label: 'Games Played', getValue: p => p.games_played || 0, sortOrder: 'desc', format: val => val }
      };

      async function fetchSheetData(sheetName) {
        try {
          const response = await fetch(BASE_URL + encodeURIComponent(sheetName));
          const csvText = await response.text();
          return parseCSV(csvText);
        } catch (error) {
          console.error(`Error fetching ${sheetName}:`, error);
          const tableBody = document.getElementById('leaderboard-table-body');
          tableBody.innerHTML = `<tr><td colspan="9" class="error">Error loading data sheet: ${sheetName}</td></tr>`;
          return null;
        }
      }
      
      function parseCSV(csvText) {
        const lines = csvText.trim().split('\n');
        const headers = lines[0].split(',').map(h => h.replace(/^"|"$/g, '').trim());
        const data = [];
        for (let i = 1; i < lines.length; i++) {
            const values = [];
            let currentVal = '';
            let inQuotes = false;
            for (let j = 0; j < lines[i].length; j++) {
                const char = lines[i][j];
                if (char === '"' && (j === 0 || lines[i][j-1] !== '\\')) { 
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    values.push(currentVal.replace(/^"|"$/g, '').trim());
                    currentVal = '';
                } else {
                    currentVal += char;
                }
            }
            values.push(currentVal.replace(/^"|"$/g, '').trim());

            if (values.length === headers.length) {
                const row = {};
                headers.forEach((header, index) => {
                    row[header] = values[index] || '';
                });
                data.push(row);
            }
        }
        return data;
      }

      function getTeamData(teamId) {
        if (!teamId) return { team_id: teamId, team_name: 'N/A', abbreviation: 'N/A' };
        const team = allTeams.find(t => t.team_id === teamId);
        return team || { team_id: teamId, team_name: teamId, abbreviation: teamId };
      }

      function getTeamLogo(teamId) {
        if (!teamId) return '';
        const team = getTeamData(teamId);
        return `<img src="icons/${encodeURIComponent(String(team.team_id || ''))}.webp" alt="${team.team_name}" class="team-logo-inline" onerror="this.style.display='none'">`;
      }

      function parsePlayerNumber(value) {
        if (value === null || value === undefined || value === '') return 0;
        const cleaned = String(value).replace(/,/g, '');
        const parsed = parseFloat(cleaned);
        return isNaN(parsed) ? 0 : parsed;
      }

      function calculatePlayerRELMedian(playerHandle, weeklyAverages, lineups) {
        const playerGames = lineups.filter(lineup =>
          lineup.player_handle === playerHandle &&
          (String(lineup.started).toLowerCase() === 'true' || lineup.started === true || lineup.started === 1)
        );
        if (playerGames.length === 0) return 0;
        const weeklyAveragesMap = {};
        (weeklyAverages || []).forEach(week => {
          if (week.date) {
            weeklyAveragesMap[week.date] = { median_score: parsePlayerNumber(week.median_score) };
          }
        });
        let totalPlayerKarma = 0, totalMedianKarma = 0, validGames = 0;
        playerGames.forEach(game => {
          if (weeklyAveragesMap[game.date]) {
            totalPlayerKarma += parsePlayerNumber(game.points_raw);
            totalMedianKarma += weeklyAveragesMap[game.date].median_score;
            validGames++;
          }
        });
        const avgPlayerKarma = validGames > 0 ? totalPlayerKarma / validGames : 0;
        const avgMedianKarma = validGames > 0 ? totalMedianKarma / validGames : 0;
        return avgMedianKarma > 0 ? (avgPlayerKarma / avgMedianKarma) : 0;
      }

      function calculatePlayerMedianRank(playerHandle, lineups) {
        const playerGames = lineups.filter(lineup =>
          lineup.player_handle === playerHandle &&
          (String(lineup.started).toLowerCase() === 'true' || lineup.started === true || lineup.started === 1) &&
          lineup.global_rank && parsePlayerNumber(lineup.global_rank) > 0
        );
        if (playerGames.length === 0) return 0; // Or perhaps '-' or Infinity depending on how it should be handled
        const ranks = playerGames.map(game => parsePlayerNumber(game.global_rank)).sort((a, b) => a - b);
        const mid = Math.floor(ranks.length / 2);
        return ranks.length % 2 === 0 ? (ranks[mid - 1] + ranks[mid]) / 2 : ranks[mid];
      }
      
      async function precalculateAllPlayerStats() {
        const enrichedPlayers = [];
        for (const player of allPlayers) { // Assuming allPlayers is raw player data initially
            const gamesPlayed = allLineupsData.filter(l => l.player_handle === player.player_handle && (String(l.started).toLowerCase() === 'true' || l.started === true || l.started === 1)).length;
            let totalScore = 0;
            let wins = 0, losses = 0, ties = 0;

            allLineupsData.forEach(l => {
                if (l.player_handle === player.player_handle && (String(l.started).toLowerCase() === 'true' || l.started === true || l.started === 1)) {
                    totalScore += parsePlayerNumber(l.points_raw);
                    if (String(l.win).toLowerCase() === 'true' || l.win === 1) wins++;
                    else if (String(l.loss).toLowerCase() === 'true' || l.loss === 1) losses++;
                    else if (String(l.tie).toLowerCase() === 'true' || l.tie === 1) ties++;
                }
            });
            
            const avgScore = gamesPlayed > 0 ? totalScore / gamesPlayed : 0;
            const relMedian = calculatePlayerRELMedian(player.player_handle, allWeeklyAverages, allLineupsData);
            const medianRank = calculatePlayerMedianRank(player.player_handle, allLineupsData);
            const teamInfo = getTeamData(player.team_id);

            enrichedPlayers.push({
                ...player,
                games_played: gamesPlayed,
                avg_score: avgScore,
                wins: wins,
                losses: losses,
                ties: ties,
                relMedian: relMedian,
                median_rank_raw: medianRank > 0 ? medianRank : '-', // Store as number or '-'
                team_name: teamInfo.team_name // Ensure team_name is available
            });
        }
        allPlayers = enrichedPlayers; // Replace raw allPlayers with enriched data
      }

      async function loadData() {
        const rawPlayersData = await fetchSheetData('Players'); // Fetch raw player list
        if (!rawPlayersData) return;
        allPlayers = rawPlayersData; // Initialize allPlayers with raw data

        const [teamsData, lineupsData, weeklyAvgsData] = await Promise.all([
          fetchSheetData('Teams'),
          fetchSheetData('Lineups'),
          fetchSheetData('Weekly_Averages')
        ]);

        if (!teamsData || !lineupsData || !weeklyAvgsData) {
          const tableBody = document.getElementById('leaderboard-table-body');
          tableBody.innerHTML = `<tr><td colspan="9" class="error">Error loading auxiliary data.</td></tr>`;
          return;
        }
        allTeams = teamsData;
        allLineupsData = lineupsData;
        allWeeklyAverages = weeklyAvgsData;
        
        await precalculateAllPlayerStats(); // This enriches allPlayers

        setupFilters();
        displayLeaderboard(); // Initial display
      }

      function setupFilters() {
        const teamSelect = document.getElementById('team-select');
        const metricSelect = document.getElementById('metric-select');

        const teamOptions = allTeams
          .filter(team => team.team_id && team.team_name && team.team_id !== "FA")
          .sort((a, b) => a.team_name.localeCompare(b.team_name))
          .map(team => `<option value="${team.team_id}">${team.team_name}</option>`)
          .join('');
        teamSelect.innerHTML = '<option value="all">All Teams</option>' + teamOptions;

        metricSelect.value = 'rel_median'; // Default metric
        sortConfig.key = 'rel_median'; // Align default sort with default metric
        sortConfig.direction = metrics['rel_median'].sortOrder;


        teamSelect.addEventListener('change', displayLeaderboard);
        metricSelect.addEventListener('change', displayLeaderboard);
      }
      
      let sortConfig = { key: 'rel_median', direction: 'desc' };

      function displayLeaderboard() {
        const metricSelect = document.getElementById('metric-select');
        const teamSelect = document.getElementById('team-select');
        const selectedMetricKey = metricSelect.value;
        const selectedTeam = teamSelect.value;

        if (!metrics[selectedMetricKey]) {
            console.error("Invalid metric selected:", selectedMetricKey);
            return;
        }

        // 1. Get all players eligible for ranking
        let rankablePlayers = allPlayers.filter(p => p.games_played > 0);

        // 2. Sort these players by the selected metric to assign ranks
        const metricDefinition = metrics[selectedMetricKey];
        rankablePlayers.sort((a, b) => {
            const valA = metricDefinition.getValue(a);
            const valB = metricDefinition.getValue(b);
            
            if (valA === valB) return 0;
            // Handle Infinity for sorting (lower median rank is better, so Infinity is "worst")
            if (metricDefinition.sortOrder === 'asc') { // Lower is better
                if (valA === Infinity) return 1;  // a is worse, comes after b
                if (valB === Infinity) return -1; // b is worse, a comes before b
                return valA - valB;
            } else { // desc, Higher is better
                if (valA === Infinity) return -1; // Should not happen if higher is better & Infinity is worst
                if (valB === Infinity) return 1;  // But if it did, handle it.
                return valB - valA;
            }
        });

        // 3. Assign ranks (standard competition ranking: 1, 2, 2, 4)
        if (rankablePlayers.length > 0) {
            rankablePlayers[0].leaderboardDisplayRank = 1;
            for (let i = 1; i < rankablePlayers.length; i++) {
                const currentPlayer = rankablePlayers[i];
                const prevPlayer = rankablePlayers[i-1];
                const currentValue = metricDefinition.getValue(currentPlayer);
                const prevValue = metricDefinition.getValue(prevPlayer);

                if (currentValue === prevValue) {
                    currentPlayer.leaderboardDisplayRank = prevPlayer.leaderboardDisplayRank;
                } else {
                    currentPlayer.leaderboardDisplayRank = i + 1; 
                }
            }
        } else {
             // Handle case with no rankable players if necessary, though filter later handles empty display
        }
        
        // 4. Filter by selected team
        currentPlayersForDisplay = rankablePlayers.filter(p => selectedTeam === 'all' || p.team_id === selectedTeam);

        // 5. Set the table's visual sort to match the selected leaderboard metric initially
        // The actual sorting for display is handled by sortPlayers if a header is clicked.
        // For initial display, currentPlayersForDisplay is already sorted by the primary metric (due to rankablePlayers sort).
        if (sortConfig.key !== selectedMetricKey) { // Update sortConfig if metric changed
            sortConfig.key = selectedMetricKey;
            sortConfig.direction = metricDefinition.sortOrder;
        }
        // No explicit sort of currentPlayersForDisplay needed here, it inherits from rankablePlayers sort.
        // If user then clicks a header, sortPlayers will take over.

        updateTableHeaders();
        populateTable();
      }

      function sortPlayers(columnKey) {
        if (!currentPlayersForDisplay) return;

        if (sortConfig.key === columnKey) {
            sortConfig.direction = sortConfig.direction === 'asc' ? 'desc' : 'asc';
        } else {
            sortConfig.key = columnKey;
            if (metrics[columnKey]) {
                sortConfig.direction = metrics[columnKey].sortOrder;
            } else if (columnKey === 'player_name' || columnKey === 'team_name') {
                sortConfig.direction = 'asc';
            } else if (columnKey === 'rank') {
                sortConfig.direction = 'asc'; // Rank is typically sorted ascending
            }
            else {
                sortConfig.direction = 'desc';
            }
        }

        currentPlayersForDisplay.sort((a, b) => {
            let valA, valB;

            if (sortConfig.key === 'rank') {
                valA = a.leaderboardDisplayRank;
                valB = b.leaderboardDisplayRank;
            } else if (metrics[sortConfig.key]) {
                valA = metrics[sortConfig.key].getValue(a);
                valB = metrics[sortConfig.key].getValue(b);
            } else if (sortConfig.key === 'player_name') {
                valA = a.player_handle.toLowerCase();
                valB = b.player_handle.toLowerCase();
            } else if (sortConfig.key === 'team_name') { // Should not be a sort key unless team name is a column
                valA = (a.team_name || "").toLowerCase();
                valB = (b.team_name || "").toLowerCase();
            } else {
                valA = a[sortConfig.key]; // Fallback, should ideally not be used
                valB = b[sortConfig.key];
            }
            
            // Handle Infinity consistently
            const isAsc = sortConfig.direction === 'asc';
            if (valA === Infinity && valB === Infinity) return 0;
            if (valA === Infinity) return isAsc ? 1 : -1; // Infinity is "largest" or "worst"
            if (valB === Infinity) return isAsc ? -1 : 1;


            if (typeof valA === 'string' && typeof valB === 'string') {
                return isAsc ? valA.localeCompare(valB) : valB.localeCompare(valA);
            } else { // Numeric comparison
                 if (valA === null || valA === undefined || isNaN(valA)) valA = isAsc ? Infinity : -Infinity;
                 if (valB === null || valB === undefined || isNaN(valB)) valB = isAsc ? Infinity : -Infinity;
                return isAsc ? valA - valB : valB - valA;
            }
        });

        updateTableHeaders();
        populateTable();
      }
      
      function populateTable() {
        const tableBody = document.getElementById('leaderboard-table-body');
        tableBody.innerHTML = ''; 

        if (currentPlayersForDisplay.length === 0) {
            const row = tableBody.insertRow();
            const cell = row.insertCell();
            const headerCells = document.getElementById('leaderboard-table-head').rows[0].cells.length;
            cell.colSpan = headerCells > 0 ? headerCells : 9; // Default to 9 if headers not ready
            cell.textContent = 'No players match the current filters.';
            cell.className = 'no-players';
            return;
        }

        currentPlayersForDisplay.forEach((player) => {
            const row = tableBody.insertRow();
            
            row.insertCell().textContent = player.leaderboardDisplayRank; 

            const nameCell = row.insertCell();
            nameCell.className = 'player-name-cell';
            
            const playerNameSpan = document.createElement('span');
            playerNameSpan.className = 'player-name';
            const playerIconHTML = getTeamLogo(player.team_id); 
            playerNameSpan.innerHTML = `${playerIconHTML} <a href="player.html?player=${encodeURIComponent(player.player_handle)}" class="player-link">${player.player_handle}</a>`;
            nameCell.appendChild(playerNameSpan);

            if (player.team_name && player.team_name !== 'N/A') {
                const teamNameSpan = document.createElement('span');
                teamNameSpan.className = 'player-team-name';
                teamNameSpan.textContent = `(${player.team_name})`;
                nameCell.appendChild(teamNameSpan);
            }
            
            row.insertCell().textContent = metrics['games_played'].format(metrics['games_played'].getValue(player));
            row.insertCell().textContent = metrics['rel_median'].format(metrics['rel_median'].getValue(player));
            row.insertCell().textContent = metrics['avg_score'].format(metrics['avg_score'].getValue(player));
            row.insertCell().textContent = metrics['median_rank_raw'].format(metrics['median_rank_raw'].getValue(player));
            row.insertCell().textContent = metrics['wins'].format(metrics['wins'].getValue(player));
            row.insertCell().textContent = metrics['losses'].format(metrics['losses'].getValue(player));
            row.insertCell().textContent = metrics['ties'].format(metrics['ties'].getValue(player));
        });
      }

      function updateTableHeaders() {
        const headers = document.querySelectorAll('#leaderboard-table-head th');
        headers.forEach(th => {
            const key = th.dataset.sortKey;
            let indicator = '';
            if (key === sortConfig.key) {
                indicator = sortConfig.direction === 'asc' ? ' ▲' : ' ▼';
            }
            // Remove existing indicators before adding new one
            th.textContent = th.textContent.replace(/ [▲▼]$/, ''); 
            th.innerHTML = `${th.textContent.trim()}<span class="sort-indicator">${indicator}</span>`;
        });
      }

      document.addEventListener('DOMContentLoaded', loadData);
      document.getElementById('leaderboard-table-head').addEventListener('click', (event) => {
          const target = event.target.closest('th');
          if (target && target.dataset.sortKey) {
              sortPlayers(target.dataset.sortKey);
          }
      });
    </script>
  </body>
</html>
